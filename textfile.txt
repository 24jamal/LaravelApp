#0:52:25 Factories & Seeders



C:\Users\jamaludeen\Herd\laravel-medium-clone>php artisan db:seed --class=PostSeeder

   INFO  Seeding database.




C:\Users\jamaludeen\Herd\laravel-medium-clone>php artisan migrate

   INFO  Running migrations.

--------------------------------------------------------------------------------------------------------

Date : 20-07-2025:

1:05:13 Output Categories & Posts :

--------------------------------------------------------------------------------------------------

Date : 22-07-2025:

1:27:09 Pagination :


CMD : C:\Users\jamaludeen\Herd\laravel-medium-clone>php artisan vendor:publish --tag=laravel-pagination 
Executes : Creates multiple bootstrap files in C:\Users\jamaludeen\Herd\laravel-medium-clone\resources\views\vendor\pagination\  path folder

---------------------------------------------------------------------------------------------------
Date : 22-07-2025:

1:33:19 Blade Directives:

https://laravel.com/docs/12.x/blade --> Refer this for Blade Directives 

In Project : I added forelse instaed of foreach
Refer Code commits exact changes.
----------------------------------------------------------------------------------------------------
Date : 22-07-2025:

1:37:46 Components

Commands executed::

C:\Users\jamaludeen\Herd\laravel-medium-clone>php artisan make:component PostItem --view

   INFO  View [C:\Users\jamaludeen\Herd\laravel-medium-clone\resources\views\components/post-item.blade.php] created successfully.  



C:\Users\jamaludeen\Herd\laravel-medium-clone>php artisan migrate:fresh --seed

  Dropping all tables ................................................................................................................. 16.80ms DONE

   INFO  Preparing database.  

  Creating migration table ............................................................................................................. 8.79ms DONE

   INFO  Running migrations.  

  0001_01_01_000000_create_users_table ................................................................................................ 34.58ms DONE
  0001_01_01_000001_create_cache_table ................................................................................................. 6.43ms DONE
  0001_01_01_000002_create_jobs_table ................................................................................................. 18.39ms DONE
  2025_07_14_175449_create_categories_table ............................................................................................ 7.97ms DONE
  2025_07_14_175513_create_posts_table ................................................................................................ 24.42ms DONE


   INFO  Seeding database.  

  Database\Seeders\PostSeeder .............................................................................................................. RUNNING  
  Database\Seeders\PostSeeder ............................................................................................................ 0 ms DONE  



-----------------------------------------------------------------------------------------------------------------------------------------------------

Date : 26-07-2025

In Laravel, a layout is a template file that defines the common structure of your web pages, such as the header, footer, navigation, and overall HTML structure.
It allows you to reuse this common code across multiple views, so your application is DRY (Don't Repeat Yourself) and easier to maintain.

Laravel uses the Blade templating engine, and layouts are typically created using Blade syntax.

Why Use Layouts?

* *Imagine you have 10 pages, and all of them share the same header and footer. Instead of copying the same code to every view, you can:

* Put that code in a layout file.

* Each individual view will just define its content section, and extend the layout.

----------------------------------------------------------------------------------------

Date : 10-08-2025
Time : 2:08:10 Create New Post

Generated Using ChatGPT:

Each file and steps use in this laravel tutorial section:
 1. web.php (Routes File)

Purpose:
This file defines URLs (routes) that map to controller methods. It tells Laravel:

> "When the user visits a specific URL, run this function."

Code from snippet:

php
Route::middleware(['auth', 'verified'])->group(function () {
    Route::get('posts/create', [PostController::class, 'create'])->name('posts.create');
    Route::post('posts', [PostController::class, 'store'])->name('posts.store');
});


Why it’s used:

* auth middleware → Only logged-in users can access.
* verified middleware → Ensures email is verified.
* GET route → Shows the "Create Post" form.
* POST route → Saves new post data into the database.



 2. PostController.php (Controller)

Purpose:
Acts as the middleman between the view (HTML form) and the model (database).
It contains logic for creating and storing posts.

Methods:

* create() → Loads the form view.
* store(Request $request) → Handles form submission.

Why it’s used:

* Validates form input.
* Uploads image if provided.
* Saves post to DB with the logged-in user's ID.
* Redirects user after saving.



 3. create_posts_table.php (Migration)

Purpose:
Defines the database table structure for posts.

Why it’s used:

* Laravel migrations let you create/update DB tables with code instead of manual SQL.
* This migration creates columns like title, body, category_id, image_path.
* Also adds relationships:

  * user_id → which user created the post.
  * category_id → category assigned to the post.



 4. create.blade.php (View Template)

Purpose:
This is the HTML form where users type in their post title, body, and optionally upload an image.

Why it’s used:

* Uses Blade syntax ({{ }}) to dynamically display old values and categories from DB.
* Has @csrf token → protects against CSRF attacks.
* Uses enctype="multipart/form-data" → allows file uploads.



 Steps to Create the "New Post" Feature

 Step 1: Create Migration & Model

bash
php artisan make:model Post -m


* Edits migration to add title, body, image\_path, category\_id, user\_id.
* Run migration:

bash
php artisan migrate




 Step 2: Create Controller

bash
php artisan make:controller PostController


* Add create() and store() methods to handle form and data saving.



 Step 3: Define Routes

* In routes/web.php, add posts.create and posts.store routes with middleware.



 Step 4: Create Blade View

* In resources/views/posts/create.blade.php, add HTML form with fields for title, body, category, and image.



 Step 5: Test Feature

* Login → go to /posts/create → fill form → submit → check database for new record.


----------------------------------------------------------------

Date : 16-08-2025
2:54:36 - Profile Update Page
Generated from ChatGPT

1. Migration (create_users_table.php)

   * Creates users table in database.
   * Defines columns: id, name, email, password, timestamps, etc.
   * Run: php artisan migrate

2. Model (User.php)

   * Represents users table (Eloquent model).
   * $fillable → Mass-assignable fields (name, email, password)
   * $hidden → Hidden in JSON (password, remember_token)
   * $casts → Attribute type casting (email_verified_at → datetime)

3. Controller (ProfileController.php)

   * Handles profile actions: edit(), update(), destroy()
   * Fetches user, updates info, redirects

4. Form Request (ProfileUpdateRequest.php)

   * Validates profile updates
   * authorize() → Who can submit
   * rules() → Validation rules (e.g., name required, email unique, password min 8)

5. Blade View (update-profile-information-form.blade.php)

   * HTML form for profile update
   * Uses @csrf for security and @method('patch') for PATCH requests
   * Inputs for name, email, password

6. How They Work Together:
   User submits form → validated by ProfileUpdateRequest → handled by ProfileController → User model updates database → view shows updated info

--------------------------------------------------------------------------------------------


Date : 16-08-2025
3:21:41 Post Details Page
Generated from ChatGPT

Post Details Page Features

Displaying Post Content: The page presents the full content of a single blog post, including the title, body, and publication date.

Author Information: It shows details about the post's author, such as their name and profile picture, providing context to the reader.

User Interactions:

Like/Unlike Functionality: Users can like or unlike the post, with the interface updating accordingly.

Follow/Unfollow Author: Readers have the option to follow or unfollow the author directly from the post page.

Comment Section: The page includes a section where users can read and post comments, fostering engagement and discussion.

Post Metadata:

Tags: Relevant tags associated with the post are displayed, aiding in content categorization.

Reading Time: An estimated reading time is shown, giving readers an idea of the post's length.

Responsive Design: The page is designed to be mobile-friendly, ensuring a seamless experience across devices.

This section of the tutorial demonstrates how to utilize Laravel's Blade templating engine,
Eloquent ORM, and routing capabilities to create a dynamic and interactive post details page.
By following this part of the course, you'll gain practical experience in building feature-rich pages that enhance user engagement.

-----------------------------------------------------------------------------------------------------------------------------

Date : 24-08-2025
3:52:05 User's Public Profile Page


📌 What happens in this part
1. Route & Controller Setup

  * A new route is added to show a specific user’s profile page.
  * A controller method fetches the user’s details (by username/ID) along with their posts.

2. Blade Template (UI)

  * A public profile page is built where visitors can see:

    * User’s name, avatar, and bio (if available).
    * List of all posts created by that user.
    * Counts for followers, following, and posts.

3. Follow/Unfollow Feature

  * A button is displayed to follow/unfollow the user.
  * Logic checks: If the logged-in user already follows, show Unfollow, otherwise Follow.
  * Clicking the button triggers the respective controller method.

4. Post Display on Profile

  * User’s posts are listed with title, excerpt, and created date.
  * Pagination is applied so the page doesn’t get overloaded.

5. Final Outcome

  * Anyone visiting `/@username` (or similar route) can see that user’s public profile page, their posts, and follow/unfollow them.

------------------------------------------------------------------------------------------------------------------------

Date : 27-08-2025

Generated from ChatGPT

Follow/Unfollow Functionality – General Notes
1. Database & Relationships

      Use a pivot table to store follow relationships between users.

      Each entry usually has:

      The user being followed.

      The follower.

      Timestamps for follow actions.

      In the User model, define followers and following relationships.

2. Backend Logic

      Implement functions to follow or unfollow a user.

      Ensure that:

      Users can’t follow the same person multiple times.

      Users can remove/unfollow a relationship when desired.

      Create routes and controllers to handle these actions.

3. Frontend Interaction (Alpine.js)

      Use reactive states to track if the current user is following another user.

      Toggle button labels dynamically (e.g., “Follow” ↔ “Unfollow”).

      Use AJAX requests to communicate with backend endpoints, avoiding full page reloads.

      Optionally update follower counts and button state in real-time.

4. Enhancements & Best Practices

      Implement loading states for better UX.

      Optionally add follow requests for privacy or approvals.

      Always validate relationships on the backend to prevent duplicates or invalid actions.

      Keep frontend lightweight and reactive using Alpine.js instead of heavy frameworks when only minor interactivity is needed.

   -----------------------------------------------------------------------------------------------------------------------

Date : 30-08-2025
4:56:20 Implement Like/Unlike Post

1. **Model Relationships**

   * Define relationships in the model (e.g., Post → likes/dislikes).
   * Add helper methods to check if a user has liked/disliked.

2. **Routes & Controller**

   * Create routes for like and dislike actions.
   * Controller handles toggling actions and prevents both like and dislike at once.

3. **Frontend Integration (Blade + Alpine.js)**

   * Render Like/Dislike buttons with initial counts from Laravel.
   * Use Alpine.js to manage state (liked, disliked, likeCount, dislikeCount).

4. **AJAX Requests**

   * Alpine.js sends requests to Laravel when buttons are clicked.
   * Update UI optimistically while waiting for backend confirmation.

5. **Laravel Response**

   * Return JSON with updated counts and user’s action status.
   * Alpine.js updates state accordingly.

6. **UI Feedback**

   * Highlight active buttons for current user’s choice.
   * Instantly update counts without page reload.

------------------------------------------------------------------------------------------------------------------------

Date : 06-09-2025

Summary of the "Show only posts from following users" segment (at 5:21:36)

In this part of the “Learn Laravel by Building a Medium Clone” tutorial, you go through the implementation of filtering the feed to display posts only from users that the current user is following. Here’s how it's typically structured:

1. Fetching Followed Users

   First, the system retrieves the list of users whom the authenticated user has followed. This is usually done via a many-to-many relationship—for example, a followers() or following() relation defined in your User model.

2. Querying Posts by Followed Users

   Next, you build a query to fetch posts whose authors are in that list of followed users.

   This might look something like:

   $followedUserIds = auth()->user()->following()->pluck('id');
   $posts = Post::whereIn('user_id', $followedUserIds)
               ->latest()
               ->get();

3. Displaying the Filtered Feed

   Finally, you pass that list of posts to your view (e.g., a Blade template) and loop through them to show only relevant content.


Recap of the Course Structure

   This tutorial is part of a step-by-step course that teaches you how to build a Medium-style platform with features like:

   User authentication (registration, login, email verification)

   Creating, editing, and deleting posts

   Implementing categories and filters

   Social features: follow/unfollow, like/unlike, and filtering posts by followers

   Image upload and resizing

   Pagination, Blade templating, and more

---------------------------------------------------------------------------------------------------------------------------

Date : 07-09-2025
5:31:33 : Image Resize

 Spatie: Who They Are

Spatie is a well-regarded web design agency based in Antwerp, Belgium, known for contributing robust open-source software to the PHP and Laravel ecosystems. They consistently share high-quality packages aimed at simplifying common development tasks — and the image and media libraries are among their most popular offerings.([Spatie][1])



 Major Spatie Packages for Images & Media

# 1. spatie/image (v3) – *Image Manipulation Library*

* Offers an expressive, chainable API to apply image transformations like resizing, cropping, filters, watermarks, and effects—making image manipulation intuitive and efficient.([Spatie][2], [GitHub][3])
* Widely used for one-off or batch image operations—whether resizing, adjusting, or applying creative filters.([Spatie][4])
* Installation is straightforward via Composer, and it supports most common image formats.([Spatie][5])



# 2. spatie/laravel-medialibrary (v11) – *Media Management for Laravel*

* Enables associating uploaded files—including images, PDFs, and videos—with Eloquent models in Laravel.([Spatie][6], [GitHub][7])
* Automatically handles image conversions, such as generating thumbnails or responsive versions, and manages storage across Laravel-supported filesystems (e.g., local disk or S3).([Spatie][6])
* Supports responsive image generation, including low-quality placeholders (LQIPs) and custom output HTML.([Spatie][6], [Reddit][8])
* Requires PHP 8.2+ and Laravel 10+, along with dependencies for processing tasks—like GD or Imagick for images, Ghostscript for PDFs, and ffmpeg for thumbnails of videos.([Spatie][9])
* Once configured, it manages media cleanly: from upload to model-linking to format conversions.([Spatie][4])



 How These Tools Work Together: A 5-Level Image Handling Journey

Spatie outlines a progression—from basic Laravel file uploads to a full-featured media workflow:

1. Basic uploads using Laravel alone—no resizing, optimization, or enhancements.
2. Add `spatie/image` to resize, crop, or adjust uploads programmatically.
3. Introduce `spatie/image-optimizer` to reduce file sizes for better performance.
4. Adopt `laravel-medialibrary` to tie media to models, generate automatic conversions, and organize files.
5. (Optional) Use Media Library Pro—a paid addon—for polished, drag-and-drop upload UIs and frontend components.([Spatie][4])


------------------------------------------------------------------------------------------------------------------------

Date : 07-09-2025
5:57:14 Home Page Optimization

What the instructor does / key goals

   Make the homepage fast and show the right posts (published posts, optionally only posts from people the current user follows). 

Concrete optimizations typically shown

      Filter posts to only show published items (use a published_at field / scopePublished).

      Order (e.g. orderBy('published_at', 'desc')) and paginate results to avoid loading everything at once.

      Use eager loading (with('user','category')) to prevent N+1 queries when rendering post author/category.

      Use withCount() (or loadCount) for likes/claps/comments so counts are retrieved in the same query.

      Select only needed columns (select('id','title','excerpt',...)) rather than * for big joins.

      Cache heavy queries or fragments (query caching, view fragment caching, or Redis) for the homepage.

      Optimize images: generate/rescale thumbnails on upload and use lazy loading to reduce page weight.

      Use view components/partials to keep blade templates efficient and avoid duplicated DB work in views.

      Consider database indexes on frequently filtered/sorted columns (e.g. published_at, user_id) to speed queries.

      Route/config caches and PHP/opcode caches for production deployment to improve overall response time. 
      Medium

Why each matters (brief)

      Eager loading + withCount reduces number of DB queries (big win for list pages).

      Pagination + selecting only necessary columns reduces memory and transfer size.

      Image resizing + lazy load improves page speed and perceived performance.

      Caching avoids repeated heavy queries on a high-traffic homepage.

------------------------------------------------------------------------------------------------------------------------------------

Date : 14-09-2025
6:11:38 Editing and Deleting Posts

From my own words:

Adding Editing and Deleting Posts on Application 
---------------------------------------------------------------------------------------------------------------
Date : 14-09-2025
6:43:26 Make image optional during Update

Make the image optional for updates. 
I created a separate PostUpdateRequest for the update (the PostCreateRequest is still used for creating). 
Submitting the edit form without an image should update the other fields.
------------------------------------------------------------------------------------------------------------------